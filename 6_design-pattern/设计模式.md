@[TOC](第4章 jvm)

# 0 格式
## 0.0 格式要求
　　换行前要求2个全角空格(html代码不要加全角空格)；
　　html代码后面一定加一行空行；
　　注意点、特点，如果换行，前面加2个全角空格；
　　标题后面需要添加空行；
　　列表全部使用ul标签控制；
　　https://www.cnblogs.com/cndarren/p/144152.html
　　视频地址：https://www.bilibili.com/video/BV1G4411c7N4?p=86
　　参考地址：http://c.biancheng.net/view/1359.html
　　每个大标题之间空2行，每个小标题之间空1行
　　<span style="color: red;"></span>
　　<hr style="height: 10px; background: green;"/>
　　<hr style="background: black;"/>
　　<div style="border: 5px black solid;"><div>
　　![avatar](pictures/11ThreadPool/11-1.png)
　　plantMUL(画UML类图)

# 1 设计模式7大原则
## 1.1 设计模式的目的

　　编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的
挑战，设计模式是为了让程序(软件)，具有更好
~~~
代码重用性(即：相同功能的代码，不用多次编写)
可读性(即：编程规范性, 便于其他程序员的阅读和理解)
可扩展性(即：当需要增加新的功能时，非常的方便，称为可维护)
可靠性(即：当我们增加新的功能后，对原来的功能没有影响)
使程序呈现高内聚，低耦合的特性
分享金句：
设计模式包含了面向对象的精髓，"懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要"
Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤
~~~

## 1.2 设计模式的7大原则

　　设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)
<hr style="background: black;"/>
　　**设计模式常用的七大原则有:**
~~~
单一职责原
接口隔离原则
依赖倒转(倒置)原则
里氏替换原则
开闭原则
迪米特法则
合成复用原则
~~~
<hr style="background: black;"/>

## 1.3 单一职责原则
### 1.3.1 基本介绍

　　对类来说的，**即一个类应该只负责一项职责**。如类A负责两个不同职责：职责1，职责 2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1、A2。

### 1.3.2 单一职责原则注意事项和细节

~~~
降低类的复杂度，一个类只负责一项职责；
提高类的可读性，可维护性；
降低变更引起的风险；
通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。
~~~

## 1.4 接口隔离原则(Interface Segregation Principle)
### 1.4.1 基本介绍

　　客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。这里的依赖是指使用的意思，比如new A().f1(new B())，即说A依赖了B，本质就是使用。
　　具体查看代码。

## 1.5 依赖倒转原则
### 1.5.1 基本介绍

　　**依赖倒转原则(Dependence Inversion Principle)是指：**
~~~
高层模块不应该依赖低层模块，二者都应该依赖其抽象；
抽象不应该依赖细节，细节应该依赖抽象；
依赖倒转(倒置)的中心思想是面向接口编程；
依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类；
使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
~~~

### 1.5.2 依赖关系传递的三种方式和应用案例

　　就是说如何把实现类传给调用类。
~~~
接口传递，即new A().f1(new B()); f1的参数是个接口；
构造方法传递：new A(new B()).f1(); A的构造方法的参数是个接口，并将new B()作为成员变量；
setter方法传递：
    A a = new A(); 
    a.setB(new B());  // 将new B()设置为成员变量
    a.f1();
~~~

### 1.5.3 依赖倒转原则的注意事项和细节

~~~
低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好；就是说被别人使用的类，最好都有接口，如果有类似的类需要新增，直接用新类实现此接口就行，不用改变调用者的类。
变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化；就是说如果成员变量是接口或抽象类，那么以后如果接口有新的实现，此类的代码也不用变。
继承时遵循里氏替换原则。
~~~

## 1.6 里氏替换原则
### 1.6.1 OO中的继承性的思考和说明

~~~
继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏；
继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障；
问题提出：在编程中，如何正确的使用继承? => 里氏替换原则。
~~~

### 1.6.2基本介绍

~~~
里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的；
如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；
在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法；
里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。
~~~

### 1.6.3 解决方法

~~~
我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。
通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替.
~~~

## 1.7 开闭原则
### 1.7.1 基本介绍

~~~
开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则；
一个软件实体如类，模块和函数应该对扩展开放(对提供方，如A调用B，则A是提供方，B是修改方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节；
当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；
编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。
~~~

## 1.8 迪米特法则
### 1.8.1基本介绍

~~~
一个对象应该对其他对象保持最少的了解；
类与类关系越密切，耦合度越大；
迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息；
迪米特法则还有个更简单的定义：只与直接的朋友通信；
直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，如果类B出现在A的"成员变量、方法参数或方法返回值"中，则类B为类A的直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。
~~~

### 1.8.2 迪米特法则注意事项和细节

~~~
迪米特法则的核心是降低类之间的耦合；
但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。
~~~

## 1.9 合成复用原则(Composite Reuse Principle)
### 1.9.1 基本介绍

　　原则是尽量使用合成、聚合的方式，而不是使用继承。
　　<hr style="background: black;"/>
　　如果B类f2()方法想使用A类f1()，不要直接让B extends A，耦合度太高，而是建议以下3种方式：
~~~
依赖：f2(A a){}
聚合：set注入
class B {
    private A a;
    public void setA(A a) {}
}
组合：
class B {
    private A a = new A(); // 类似spring的自动注入方式
}
~~~

## 1.10 设计原则核心思想

~~~
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起；
针对接口编程，而不是针对实现编程；
为了交互对象之间的松耦合设计而努力。
~~~



# 2 UML类图
## 2.1 idea使用UML插件安装

~~~
File -> Settings -> Plugins -> PlantUML intergration安装插件；
https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi 安装graphviz软件到本地；
配置环境变量：
    配置GRAPHVIZ_HOME：本地安装目录(与JAVA_HOME类似)；
    配置GRAPHVIZ_DOT：变量值为%GRAPHVIZ_HOME%\bin\dot.exe
    配置Path：%GRAPHVIZ_HOME%\bin
    cmd -> dot -version 查看是否配置成功。
Settings -> 搜索plantuml -> graphviz dot executable 选择本地 安装目录\bin\dot.exe这个文件。
~~~

## 2.2 UML基本介绍

~~~
UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果；
UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等；
使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模。
~~~

## 2.3 UML图

　　画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类：
~~~
用例图(use case)；
静态结构图：类图(类图是描述类与类之间的关系的，是UML图中最核心的)、对象图、包图、组件图、部署图；
动态行为图：交互图(时序图与协作图)、状态图、活动图。
~~~

## 2.4 UML类图

~~~
用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系；
类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。
注意：类图中
    字段，是字段类型在":"之后，其它信息在之前，如"name : String"；
    方法返回值在":"之后，其它在之前，如"setName(name : String) : void"，参数也是一样，变量类型在后面。
~~~

### 2.4.1 依赖关系(Dependence)

　　只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。依赖表示要做一件事情，离不开某个对象。往往表现为B作为A的方法参数存在(A依赖B)
~~~
类中用到了对方；
如果是类的成员属性；
如果是方法的返回类型；
是方法接收的参数类型；
方法中使用到。
~~~

### 2.4.2 关联关系(Association)

　　关联关系实际上就是类与类之间的联系，是依赖关系的特例，即一个做为另一个的属性。关联表示has-a关系，如学生拥有一个课程，往往表现为B作为A的属性存在(A关联B)
~~~
关联关系具有导航性：即双向关联或单向关联；
关联关系具有多重性：如"1"表示有且仅有一个，"0"表示0个或多个，"0, 1"表示0或1个，"n...m"表示n到m个，"m...*"表示至少m个。
~~~

### 2.4.3 泛化关系(generalization)

　　泛化关系实际上就是继承关系，他是依赖关系的特例
~~~
泛化关系实际上就是继承关系；
如果 A extends B 类，我们就说A和B存在泛化关系。
~~~

### 2.4.4 实现关系(Implementation)

　　实现关系实际上就是 A 类实现 B 接口，是依赖关系的特例

### 2.4.5 聚合关系(Aggregation)

　　聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。
　　如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示。

### 2.4.6 组合关系(Composition)

　　组合关系：也是整体与部分的关系，但是整体与部分不可以分开，即成员变量 A a = new A()，和所属对象的生命周期一样，同生共死都算。
　　再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么Head和Person就是组合，IDCard和Person 就是聚合。
　　但是如果在程序中 Person 实体中定义了对IDCard进行级联删除，即删除 Person 时连同 IDCard 一起删除，那么IDCard和Person。

## 2.5 UML类图语法

　　语法介绍 https://plantuml.com/zh/class-diagram
　　**从上到下按如下格式来**
~~~
所有接口、类名称声明
所有类之间的关系描述
所有类属性、方法描述
~~~

### 2.5.1 元素声明

　　查看com\xyb\a2uml\1元素声明.puml。

### 2.5.2 类之间的关系与备注写法

~~~
<|、|>、^：空心三角形；
>、<：箭头；
*：代表实心菱形；
o：空心菱形；
--：实线；
..：虚线；
.或-越多线越长；一个.或-是垂直显示；
泛化的实现关系或以直接写extends和implements，uml依然会用实线、虚线显示，不过类前面要加class、interface
其余查看：com\xyb\a2uml\2类之间关系.puml
~~~

### 2.5.3 添加方法和属性

　　com\xyb\a2uml\3添加字段和方法.puml。
　　**特殊说明**
~~~
-、#、~、+：private、protected、package private、public，分别显示"正方形(red)、菱形(yellow)、三角形(blue)、圆形(green)"，修饰属性是空心，方法是实心；
类中的属性属性或方法，有()会被认为是方法(在属性下面的方框)，否则为属性(在类名下面的方框)；
{field}、{method}：被{field}修饰的会被认为是属性，即使有()，{method}修饰即使没()也被认为方法；
{static}、{classifier}、{abstract}：描述静态(显示下划线)、静态(显示下划线)、抽象(斜体)；
在类上面使用 'skinparam classAttributeIconSize 0'可以使'- # ~ +'失效
~~~

### 2.5.4 高级类体

　　PlantUML默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都是可用的：--、..、==、__。
　　还可以在分隔符中添加标题，查看com\xyb\a2uml\4高级类体.puml

### 2.5.6 备注和模板

　　com\xyb\a2uml\5备注和模板.puml
~~~
以下以左举例，上下右类似
方式1：在类声明的下一行
    class C1
    note left: 这是C1左侧的备注

方式2：在类声明的下面即可
    class C1
    note left on C1：这是C1左侧的备注

方式3：将note 起一个别名
    note "这是一个备注" as N1
    class C1
    class C2
    C1 .. N1 // 这里将N1这个备注添加到C1的下边或右边
    N1 .. C2 // 这里将N1这个备注添加到C2的上边或左边
~~~
<hr style="background: black;"/>

　　**备注可以使用html**
~~~
<b>
<u>
<i>
<s>, <del>, <strike>
<font color="#AAAAAA"> or <font color="colorName">
<color:#AAAAAA> or <color:colorName>
<size:nn> to change font size
<img src="file"> or <img:file>: the file must be accessible by the filesystem
~~~

### 2.5.7 注释属性和方法

　　com\xyb\a2uml\6注释属性和方法.puml

### 2.5.8 类成员的箭头方向(Arrows from/to class members)

　　可以关联A.field1和B.field2的关系，如LCCont.grpContNo = LcGrpCont.grpContNo



# 3 设计模式概述
## 3.1 设计模式介绍

~~~
设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式(Design pattern)代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的；
设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度；
<<设计模式>> 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design(俗称 "四人组 GOF")；
设计模式并不局限于某种语言，java，php，c++ 都有设计模式。
~~~

## 3.2 设计模式类型

　　**设计模式分为三种类型，共 23 种**
~~~
创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式；
结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；
行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter 模式)、状态模式、策略模式、职责链模式(责任链模式)
~~~



# 5 单例设计模式
## 5.1 单例设计模式介绍

　　所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。

## 5.2 单例设计模式的几种种方式

~~~
饿汉式(线程安全，"静态常量"或"静态代码块")；
懒汉式(线程安全，同步方法)；
双重检查(推荐使用)；
静态内部类；
枚举。
~~~

<hr style="background: black;"/>

　　**饿汉式(静态常量)、(静态代码块)**
~~~
步骤
    构造器私有化(防止 new)；
    类的内部创建对象，在类初始化阶段<clinit>()；
    向外暴露一个静态的公共方法，getInstance。
    查看：com\xyb\a3singleton\A1Singleton.java

优缺点说明：
优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题；
缺点：
    在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费；
这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果；
结论：这种单例模式可用，可能造成内存浪费
~~~

<hr style="background: black;"/>

　　**懒汉式(线程安全，不推荐使用)**
~~~
步骤：
    提供一个静态的公有方法，当使用到该方法时，才去创建 instance；
    查看：com\xyb\a3singleton\A2LazyLoading.java。

优缺点说明：
    效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低。

结论：在实际开发中，不推荐使用这种方式。
~~~

<hr style="background: black;"/>

　　**双重检查(推荐使用)**
~~~
优缺点说明：
    Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if(singleton == null)检查，这样就可以保证线程安全了。
    这样，实例化代码只用执行一次，后面再次访问时，判断 if(singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步. 
    线程安全；延迟加载；效率较高。
查看：com\xyb\a3singleton\A3DoubleCheck.java

注意，单例前必须加上volatile关键字。TODO

结论：在实际开发中，推荐使用这种单例设计模式
~~~

<hr style="background: black;"/>

　　**静态内部类(推荐使用)**
~~~
其实是"饿汉式"的变化，"饿汉式"的缺点是每个类只要初始化<clinit>()，则单例对象必定被创建，占用内存，那如果将这个单例对象写在私有静态内部类里面，只有在获取单例对象的时候，内部类才进行初始化<clinit>()，那不也相当于lazy loading，而且加载过程<clinit>()也是线程安全的，推荐使用。

优缺点说明：
    这种方式采用了类装载的机制来保证初始化实例时只有一个线程；
    静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。
    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
    优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
查看：com\xyb\a3singleton\A4StaticInnerClass.java。

结论：推荐使用
~~~

<hr style="background: black;"/>

　　**枚举(推荐使用)**
~~~
优缺点说明：
    这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建
新的对象。
    这种方式是 Effective Java 作者 Josh提倡的方式。
~~~

## 5.3 单例模式在 JDK 应用的源码
### 5.3.1 单例模式在 JDK 应用的源码分析

　　Runtime这个类就是使用的"饿汉式"单例模式。

### 5.3.2 单例模式注意事项和细节说明

~~~
单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new；
单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)。
~~~



# 6 工厂模式
## 6.1 简单工厂模式
### 6.1.1 基本介绍

~~~
简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式；
简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)；
在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。
查看：com\xyb\a4factory\a2simple。
~~~

## 6.2 工厂方法模式

　　工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
　　查看com\xyb\a4factory\a3factorymethod。

## 6.3 抽象工厂模式

~~~
抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类；
抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合；
从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)；
将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

查看com\xyb\a4factory\a4absfactory。
~~~

## 6.4 工厂模式在 JDK-Calendar 应用的源码分析

　　JDK 中的 Calendar 类中，就使用了简单工厂模式



# 7 原型模式
## 7.1 定义与特点

~~~
原型(Prototype)模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。它属于创建型设计模式，用于创建重复的对象，同时又能保证性能(用这种方式创建对象非常高效)。
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
~~~

## 7.2 优缺点

~~~
性能优良：原型模式是在内存二进制流的拷贝，要比new一个对象性能好很多，特别是在一个循环体类产生大量对象的时候更加明显；
逃避构造函数的约束：这是优缺点共存的一点，直接在内存中拷贝，构造函数是不会执行的。
需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。
~~~

## 7.3 使用场景

~~~
资源初始化场景：类初始化需要消耗非常多的资源的时候；
性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备和访问权限的时候；
一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而各个调用者可能都需要修改其值时考虑使用；
实际项目中原型模式很少单独出现，一般和工厂模式一起出现，通过clone方法创建一个对象，然后由工厂方法提供给调用者。
~~~

## 7.4 结构与实现

　　由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单，只需要实现Cloneable接口并重写clone()方法，简单程度仅次于单例模式和迭代器模式。
　　原型模式包含以下主要角色：
~~~
抽象原型类：规定了具体原型对象必须实现的接口，java中即Cloneable接口；
具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象，即被克隆对象的类；
访问类：使用具体原型类中的 clone() 方法来复制新的对象，即使用克隆后对象的类。
查看com\xyb\a5prototype\A1PrototypeCls.java。
~~~

　　注意：构造方法在clone的时候并不会执行，因为对象是从内存以二进制流的方式进行拷贝，当然不会执行。

## 7.5 深拷贝、浅拷贝

　　查看com\xyb\a5prototype\2深浅拷贝.puml，对对象A进行浅拷贝是指复制A中所有属性的值(基本类型记录值、引用类型记录存的地址)。

　　深拷贝
~~~
复制对象的所有基本数据类型的成员变量值；
为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
深拷贝实现方式 1：重写 clone 方法来实现深拷贝(不推荐，需要让此对象可达的对象的类实现Cloneable接口)；
深拷贝实现方式 2：通过对象序列化实现深拷贝(推荐)
~~~



# 8 建造者模式
## 8.1 基本介绍

~~~
建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象；
建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
简单来说，有2种建造者模式：
    1、直接返回一个有默认值的对象，比如JVM参数，当你运行一个main方法时，即使什么也不设置，也可以运行，因为它默认把这些参数都设置了，你可以直接使用；
    2、通过set方法返回此Builder，使其可以继续设置属性，最终返回一个对象。
~~~

## 8.2 建造者模式的4个对象

~~~
Product(产品角色)：一个具体的产品对象；
Builder(抽象建造者)：创建一个Product对象的各个部件指定的 接口/抽象类；
ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件；
Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。
查看：com\xyb\a6builder\1建造者模式.puml。
~~~

## 8.3 建造者模式在 JDK 的应用和源码分析

　　java.lang.StringBuilder 中的建造者模式
~~~
Appendable接口定义了多个append方法(抽象方法)，即Appendable为抽象建造者，定义了抽象方法；
AbstractStringBuilder实现了Appendable接口方法，这里的AbstractStringBuilder已经是建造者，只是不能实例化；
StringBuilder即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了 AbstractStringBuilder。
~~~

## 8.4 建造者模式的注意事项和细节

~~~
客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象；
每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象；
可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程；
增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合"开闭原则"；
建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制；
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。
~~~

## 8.5 抽象工厂模式 VS 建造者模式

　　抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。



# 9 适配器设计模式
## 9.1 基本介绍

~~~
适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)；
适配器模式属于结构型模式；
主要分为三类：类适配器模式、对象适配器模式、接口适配器模式(缺省适配器模式)。
~~~

## 9.2 工作原理

~~~
适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容；
从用户的角度看不到被适配者，是解耦的；
用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法；
用户收到反馈结果，感觉只是和目标接口交互。
~~~

## 9.3 类适配器模式

　　基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。
　　即A类想用b()方法，但是没有b()，就让A类的子类B添加这个b()，那么直接调用B.b()就实现A类调用了b()方法(B类也是A类)，那怎么让B有b()方法，让B实现接口中有b()的接口。

~~~
源(Adaptee)：需要被适配的对象或类型，相当于插头；
适配器(Adapter)：连接目标和源的中间对象，相当于插头转换器；
目标(Target)：期待得到的目标，相当于插座。
~~~

### 9.3.1 类适配器模式注意事项和细节

~~~
Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性；
src类的方法在Adapter中都会暴露出来，也增加了使用的成本；
由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。
~~~

## 9.4 对象适配器模式
### 9.4.1 模式介绍

~~~
基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配；
根据"合成复用原则"，在系统中尽量使用关联关系(聚合)来替代继承关系；
对象适配器模式是适配器模式常用的一种。
~~~

### 9.4.2 对象适配器模式注意事项和细节

~~~
对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。
根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口；
使用成本更低，更灵活。
~~~

## 9.5 接口适配器模式
### 9.5.1 接口适配器模式介绍

~~~
一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式；
核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求；
适用于一个接口不想使用其所有的方法的情况。
JDK8以后接口可以用default修饰方法，同样可以实现。
~~~

## 9.6 适配器模式在 SpringMVC 框架应用的源码剖析

~~~
SpringMvc中的HandlerAdapter，就使用了适配器模式
SpringMVC 处理请求的流程回顾
    使用HandlerAdapter的原因分析:
    可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则。
~~~

## 9.7 适配器模式的注意事项和细节

~~~
三种命名方式，是根据 src 是以怎样的形式给到 Adapter(在 Adapter 里的形式)来命名的：
    类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承；
    对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有；
    接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现。
Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作；
实际开发中，实现起来不拘泥于我们讲解的三种经典形式。
~~~



# 10 桥接模式
## 10.1 基本介绍

　　桥接(Bridge)模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

## 10.2 优缺点

~~~
优点：
    抽象与实现分离，扩展能力强；
    符合开闭原则；
    符合合成复用原则；
    其实现细节对客户透明。
缺点：
    由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。
~~~

## 10.3 主要角色

~~~
抽象化(Abstraction)角色：定义抽象类，并包含一个对实现化对象的引用；
扩展抽象化(Refined Abstraction)角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法；
实现化(Implementor)角色：定义实现化角色的接口，供扩展抽象化角色调用；
具体实现化(Concrete Implementor)角色：给出实现化角色接口的具体实现。
具体查看com\xyb\a8bridge\1桥接模式.puml。
~~~

## 10.4 桥接模式在 JDBC 的源码剖析


## 10.5 桥接模式的注意事项和细节

~~~
实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统；
对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成；
桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本；
桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程；
桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。

桥接模式其它应用场景：对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适合。
~~~

## 10.6 常见的应用场景

~~~
JDBC 驱动程序
银行转账系统
    转账分类: 网上转账，柜台转账，AMT 转账
    转账用户类型：普通用户，银卡用户，金卡用户.. 
3) -消息管理
    消息类型：即时消息，延时消息
    消息分类：手机短信，邮件消息，QQ 消息
~~~



# 11 装饰者模式
## 11.2 定义

　　装饰者模式(Decorator Pattern) 是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。装饰者模式动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为"油漆工模式"，它是一种对象结构型模式。即不改变原有类的情况下，增强其功能。

## 11.3 装饰者模式在JDK应用的源码分析

　　FilterInputStream 就是一个装饰，查看com\xyb\a9decorator\1装饰者模式.puml。

~~~
InputStream 是抽象类, 类似我们前面讲的 Drink
FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf, LongBlack
FilterInputStream 是 InputStream 子类：类似我们前面 的 Decorator 修饰者
DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等
FilterInputStream 类 有 protected volatile InputStream in; 即含被装饰者
分析得出在 jdk 的 io 体系中，就是使用装饰者模式
~~~



# 12 组合模式
## 12.1 基本介绍

~~~
 组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示"整体-部分"的层次关系；
组合模式依据树形结构来组合对象，用来表示部分以及整体层次；
这种类型的设计模式属于结构型模式；
组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点；
其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型(用统一接口定义)，让它们具备一致行为。
这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。
组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。
~~~

## 12.2 优缺点

~~~
组合模式的主要优点有：
    组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
    更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足"开闭原则"；

其主要缺点是：
    设计较复杂，客户端需要花更多时间理清类之间的层次关系；
    不容易限制容器中的构件；
    不容易用继承的方法来增加构件的新功能；
~~~

## 12.3 模式的结构

　　组合模式包含以下主要角色：
~~~
抽象构件(Component)角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。(总的抽象类或接口，定义一些通用的方法，比如新增、删除)
树叶构件(Leaf)角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件；
树枝构件(Composite)角色/中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。
~~~

　　<hr style="background: black;"/>

　　组合模式分为透明式的组合模式和安全式的组合模式。
　　透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们(空实现或抛异常)，这样会带来一些安全性问题。
　　安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。
　　<hr style="background: black;"/>
　　组合模式的应用场景
~~~
在需要表示一个对象整体与部分的层次结构的场合；
要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。
~~~



# 13 外观模式(Facade模式)
## 13.1 问题

　　在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。
　　软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了"开闭原则"，也违背了"迪米特法则"，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。

## 13.2 外观模式的定义与特点

　　外观(Facade)模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

　　在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统(2个以上的类对象)，我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。
　　<hr style="background: black;"/>
　　外观(Facade)模式是"迪米特法则"的典型应用，它有以下主要优点：
~~~
降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。
~~~
　　<hr style="background: black;"/>
　　外观(Facade)模式的主要缺点如下：
~~~
不能很好地限制客户使用子系统类，很容易带来未知风险；
增加新的子系统可能需要修改外观类或客户端的源代码，违背了"开闭原则"。
~~~

## 13.3 外观模式的结构与实现

　　外观(Facade)模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。
　　<hr style="background: black;"/>
　　外观(Facade)模式包含以下主要角色。
~~~
外观(Facade)角色：为多个子系统对外提供一个共同的接口，外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象；
子系统(Sub System)角色：实现系统的部分功能，处理 Facade 对象指派的任务，他是功能的实际提供者，客户可以通过外观角色访问它；
客户(Client)角色：通过一个外观角色访问各个子系统的功能。
~~~

## 13.4 外观模式的应用场景

　　通常在以下情况下可以考虑使用外观模式：
~~~
对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系；
当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问；
当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。
~~~

## 13.5 外观模式的扩展

　　外观模式中，当增加或移除子系统时需要修改外观类，这违背了"开闭原则"。如果引入抽象外观类，则在一定程度上解决了该问题。查看com\xyb\a11facade\1外观模式.puml。



# 14 享元模式(Flyweight Pattern)
## 14.1 基本介绍

　　在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。

　　享元(Flyweight Pattern)模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

　　享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建5个对象来画出20个分布于不同位置的圆来演示这种模式。由于只有5种可用的颜色，所以color属性被用来检查现有的Circle对象。

## 14.2 优缺点

　　享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。

　　其主要缺点是：1、为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性；2、读取享元模式的外部状态会使得运行时间稍微变长。

## 14.3 享元模式的结构与实现

　　享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。
　　内部状态指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变；
　　外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。

　　比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。

　　享元模式的本质是缓存共享对象，降低内存消耗。
　　<hr style="background: black;"/>
　　模式的结构
~~~
抽象享元角色(Flyweight)：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入；
具体享元角色(Concrete Flyweight)：实现抽象享元角色中所规定的接口；
非享元(Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中；
享元工厂(Flyweight Factory)角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。
~~~



# 15 代理模式
## 15.1 问题

　　在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过12306网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

　　在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大(如视频或大图像等)，其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

## 15.2 定义

　　代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

## 15.3 结构与实现

　　代理模式的主要角色如下：
~~~
抽象主题(Subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法；
真实主题(Real Subject)类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象；
代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
~~~
　　<hr style="background: black;"/>
　　根据代理的创建时期，代理模式分为静态代理和动态代理：
~~~
静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了；
动态：在程序运行时，运用反射机制动态创建而成。
~~~

## 15.4 应用场景
　　当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

　　前面分析了代理模式的结构与特点，现在来分析以下的应用场景：
~~~
远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间；
虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉；
安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限；
智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它；
延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。
~~~

## 15.5 优缺点

　　优点：
~~~
代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
代理对象可以扩展目标对象的功能；
代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。
~~~
　　<hr style="background: black;"/>
　　缺点：
~~~
代理类和被代理类实现了相同的接口，导致代码的重复，如果接口增加一个方法，那么除了被代理类需要实现这个方法外，代理类也要实现这个方法，增加了代码维护的难度；
代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了；
解决方法是使用动态代理。
~~~

## 15.6 代理模式的扩展1：JDK动态代理

　　所谓动态代理是指：在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能。动态代理主要分为JDK动态代理和cglib动态代理两大类。




# 16 模板方法模式
## 16.1 问题

　　在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。
  
　　例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。
  
　　这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中"做事"的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。
  
　　以下介绍的模板方法模式将解决以上类似的问题。

## 16.2 定义

　　模板方法(Template Method)模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

## 16.3 优缺点

　　优点：
~~~
它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展；
它在父类中提取了公共的部分代码，便于代码复用；
部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。
~~~
　　<hr style="background: black;"/>
　　缺点：
~~~
对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度；
父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度；
由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。
~~~

## 16.4 结构与实现

　　模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及"不用调用我，让我来调用你"的反向控制技术。现在来介绍它们的基本结构。

　　主要包含以下角色：
~~~
抽象类/抽象模板(Abstract Class)，抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：
    模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法；
    基本方法：是整个算法中的一个步骤，包含以下几种类型
        抽象方法：在抽象类中声明，由具体子类实现；
        具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它；
        钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种

具体子类/具体实现(Concrete Class)，具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。
~~~

　　钩子方法：
~~~
不是由该方法的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
如果某个子类需要在ConcreteMethod方法后，在AbstractMethod方法前进行某些操作，就可以覆盖这个钩子方法，实现自己的逻辑即可，并不需要修改父类或其调用方。
钩子就是在整体流程的设计中，故意留下的供子类灵活变更的钥匙。
钩子是一种被声明在抽象类中的方法，但钩子只有空的或者默认方法实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩由子类自行决定。
当在模板方法中某一些步骤是可选的时候，也就是该步骤不一定要执行，可以由子类来决定是否要执行，则此时就需要用上钩子。钩子是一种被声明在抽象类中的方法，但一般来说它只是空的或者具有默认值，子类可以实现覆盖该钩子，来设置算法步骤的某一步骤是否要执行。钩子可以让子类实现算法中可选的部分，让子类能够有机会对模板方法中某些一即将发生的步骤做出反应。
~~~

## 16.4 模式的应用场景

　　算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
　　当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
　　当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。

## 16.5 模式的扩展

　　在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用"钩子方法"可以使得子类控制父类的行为。

## 16.6 模板方法模式在 Spring 框架应用的源码分析

　　Spring IOC 容器初始化时运用到的模板方法模式。



# 17 命令模式
## 17.1 问题

　　在软件开发系统中，"方法的请求者"与"方法的实现者"之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行"撤销、重做、记录"等处理都很不方便，因此"如何将方法的请求者与实现者解耦？"变得很重要，命令模式就能很好地解决这个问题。

　　在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器(命令发送者)通过按钮(具体命令)来遥控电视机(命令接收者)。

## 17.2 定义及优缺点

　　命令(Command)模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。
　　<hr style="background: black;"/>
　　优点：
~~~
通过引入中间件(抽象接口)降低系统的耦合度；
扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足"开闭原则"；
可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令；
方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复；
可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。
~~~
　　<hr style="background: black;"/>
　　缺点：
~~~
可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性；
命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构(引入了请求方与抽象命令接口)，增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。
~~~

## 17.3 结构

　　命令模式包含以下主要角色：
~~~
抽象命令类(Command)角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()；
具体命令类(Concrete Command)角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作；
实现者/接收者(Receiver)角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者；
调用者/请求者(Invoker)角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。
~~~



# 18 访问者模式
## 18.1 问题 

　　被访问的东西是不变的，但是不同的人关注点(即属性)不一样。

　　在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。

　　这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在"购物车"中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。

　　这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用"访问者模式"来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。

## 18.2 定义与特点

　　访问者(Visitor)模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。
　　<hr style="background: black;"/>
　　访问者(Visitor)模式是一种对象行为型模式，其主要优点如下：
~~~
扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能；
复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度；
灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构；
符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。
~~~
　　<hr style="background: black;"/>
　　访问者(Visitor)模式的主要缺点如下：
~~~
增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了"开闭原则"；
破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性；
违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。
~~~

## 18.3 结构

　　访问者模式包含以下主要角色：
~~~
抽象访问者(Visitor)角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素；
具体访问者(ConcreteVisitor)角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么；
抽象元素(Element)角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数；
具体元素(ConcreteElement)角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作；
对象结构(Object Structure)角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。
~~~



# 19 迭代器模式
## 19.1 问题

　　在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如"数据结构"中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了"开闭原则"。
  
　　既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：
　　暴露了聚合类的内部表示，使其数据不安全(用户不应该知道类内部使用的何种表示)；
　　增加了客户的负担(用户不需要知道类内部使用何种表示)。

　　迭代器模式"能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足"单一职责原则"和"开闭原则"，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。即用户每次遍历的时候，都去获取对应的迭代器，不管类里面是用的何种容器，便于用户操作。另外，如果用户想要倒序遍历，则不用修改类代码，只用修改迭代器代码。

## 19.2 定义与特点

　　迭代器(Iterator)模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式。
　　<hr style="background: black;"/>
　　优点：
~~~
访问一个聚合对象的内容而无须暴露它的内部表示；
遍历任务交由迭代器完成，这简化了聚合类；
它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历；
增加新的聚合类和迭代器类都很方便，无须修改原有代码；
封装性良好，为遍历不同的聚合结构提供一个统一的接口。
~~~
　　<hr style="background: black;"/>
　　缺点：增加了类的个数，这在一定程度上增加了系统的复杂性。
　　在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。

## 19.3 结构

　　迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。
　　<hr style="background: black;"/>
　　迭代器模式主要包含以下角色：
~~~
抽象聚合(Aggregate)角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口；
具体聚合(ConcreteAggregate)角色：实现抽象聚合类，返回一个具体迭代器的实例；
抽象迭代器(Iterator)角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、first()、next()等方法；
具体迭代器(Concretelterator)角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。
~~~



# 20 观察者模式
## 20.1 问题

　　在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。

## 20.2 定义与特点

　　观察者(Observer)模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。说是观察者，其实是被观察目标改变了，主动通知的观察者。
　　<hr style="background: black;"/>
　　观察者模式是一种对象行为型模式，其主要优点如下：
~~~
降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
目标与观察者之间建立了一套触发机制。
~~~
　　<hr style="background: black;"/>
　　它的主要缺点如下：
~~~
目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
~~~

## 20.3 结构

　　实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。
　　<hr style="background: black;"/>
　　观察者模式的主要角色如下：
~~~
抽象主题(Subject)角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法；
具体主题(Concrete Subject)角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象；
抽象观察者(Observer)角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用；
具体观察者(Concrete Observer)角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。
~~~

## 20.4 应用场景

　　在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。

　　通过前面的分析与应用实例可知观察者模式适合以下几种情形：
~~~
对象间存在一对多关系，一个对象的状态发生改变会影响其他对象；
当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用；
实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播；
多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域(跨越两种观察者类型)通知。
~~~

## 20.5 扩展

　　在Java中，通过java.util.Observable类和java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。

　　1. Observable类
　　Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。
　　void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。
　　void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。
　　void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。

　　2. Observer 接口
　　Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。



# 21 中介者模式
## 21.1 问题

　　在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是"网状结构"，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他(她)所有朋友的电话；而且，朋友中如果有人的电话修改了，他(她)必须让其他所有的朋友一起修改，这叫作"牵一发而动全身"，非常复杂。
  
　　如果把这种"网状结构"改为"星形结构"的话，将大大降低它们之间的"耦合性"，这时只要找一个"中介者"就可以了。如前面所说的"每个人必须记住所有朋友电话"的问题，只要在网上建立一个每个朋友都可以访问的"通信录"就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找"房屋中介"；或者，自己刚刚到一个陌生城市找工作，可以找"人才交流中心"帮忙。

## 21.2 定义与特点

　　中介者(Mediator)模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。
　　<hr style="background: black;"/>
　　中介者模式是一种对象行为型模式，其主要优点如下：
~~~
类之间各司其职，符合迪米特法则；
降低了对象之间的耦合性，使得对象易于独立地被复用；
将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。
~~~
　　<hr style="background: black;"/>
　　其主要缺点是：中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。

## 21.3 结构

　　中介者模式包含以下主要角色：
~~~
抽象中介者(Mediator)角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法；
具体中介者(Concrete Mediator)角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色；
抽象同事类(Colleague)角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能；
具体同事类(Concrete Colleague)角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。
~~~

## 21.4 应用场景

　　当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。
　　当想创建一个运行于多个类之间的对象，又不想生成新的子类时。

## 21.5 扩展

　　在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单：
~~~
不定义中介者接口，把具体中介者对象实现成为单例；
同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。
~~~



# 22 备忘录模式
## 22.1 问题

　　每个人都有犯错误的时候，都希望有种"后悔药"能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供"后悔药"给他们呢？当然是可以的，而且是有必要的。这个功能由"备忘录模式"来实现。

　　其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。

　　备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。

## 22.2 定义与特点

　　备忘录(Memento)模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。
　　<hr style="background: black;"/>
　　备忘录模式是一种对象行为型模式，其主要优点如下：
~~~
提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态；
实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息；
简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。
~~~
　　<hr style="background: black;"/>
　　其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

## 22.3 结构

　　备忘录模式的主要角色如下：
~~~
发起人(Originator)角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息，是需要保存状态的对象；
备忘录(Memento)角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人；
管理者(Caretaker)角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改；
说明：如果希望保存多个 originator 对象的不同时间的状态，也可以，只需要要 HashMap <String, 集合>
~~~



# 24 解释器模式
## 24.1 问题

　　在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用"编译原理"中的解释器模式来实现了(如spring解析bean标签)。

　　虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。

## 24.2 定义与特点

　　解释器(Interpreter)模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。

　　这里提到的文法和句子的概念同编译原理中的描述相同，"文法"指语言的语法规则，而"句子"是语言集中的元素。例如，汉语中的句子有很多，"我是中国人"是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。
　　<hr style="background: black;"/>
　　解释器模式是一种类行为型模式，其主要优点如下：
~~~
扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法；
容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
~~~
　　<hr style="background: black;"/>
　　解释器模式的主要缺点如下：
~~~
执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦；
会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护；
可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。
~~~

## 24.3 结构

　　解释器模式包含以下主要角色：
~~~
抽象表达式(Abstract Expression)角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()；
终结符表达式(Terminal Expression)角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应；
非终结符表达式(Nonterminal Expression)角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式；
环境(Context)角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值；
客户端(Client)：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。
~~~



# 25 状态模式
## 25.1 问题

　　人有高兴、平静和不高兴的状态，当处理于不同状态时，我们对同一件事的反应或者行为是不一样的，比如吃饭行为。当人吃饭的时候，不同的状态导致吃饭量不一样，如果写在吃饭方法内，则后面如果增加状态，会违反开闭原则。且吃饭后对心情也是有影响的。

## 25.2 定义与特点

　　状态(State)模式的定义：对有状态的对象，把复杂的"判断逻辑"提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

　　<hr style="background: black;"/>
　　状态模式是一种对象行为型模式，其主要优点如下：
~~~
结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足"单一职责原则"；
将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖；
状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。
~~~

　　<hr style="background: black;"/>
　　状态模式的主要缺点如下：
~~~
状态模式的使用必然会增加系统的类与对象的个数；
状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱；
状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。
~~~

## 25.3 结构

　　状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。

　　<hr style="background: black;"/>
　　状态模式包含以下主要角色：
~~~
环境类(Context)角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换；
抽象状态(State)角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为；
具体状态(Concrete State)角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。
~~~



# 26 策略模式
## 26.1 问题

　　从北京到上海有多种方式，即策略，可以坐火车、大巴，也可能因为经济发展，坐高铁、飞机、轮船等。如果把策略用if...else写死在代码里，再扩展的时候违背开闭原则。这个与依赖倒置简直一模一样。

## 26.2 定义与特点

　　策略(Strategy)模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

　　<hr style="background: black;"/>
　　策略模式的主要优点如下：
~~~
多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。
策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。
~~~

　　<hr style="background: black;"/>
  　　其主要缺点如下:
~~~
客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
策略模式造成很多的策略类，增加维护难度。
~~~

## 26.3 结构

　　策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。

　　<hr style="background: black;"/>
　　策略模式包含以下主要角色：
~~~
抽象策略(Strategy)类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
具体策略(Concrete Strategy)类：实现了抽象策略定义的接口，提供具体的算法实现。
环境(Context)类：持有一个策略类的引用，最终给客户端调用。
~~~



# 27 职责链模式(责任链模式)
## 27.1 问题

　　一个需求从提出到上线需要经过如下步骤：需求提出、需求评审、设计评审、代码开发、流转测试、流转业务、发布。如果这些事情由一个人来进行流程流转是很麻烦的事情，因为每个流程需要找不同的人，开发不同的系统找的人也不一样。可以采用责任链模式。一个流程结束后，自动流转到下个节点。

## 27.2 定义与特点

　　责任链(Chain of Responsibility)模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

　　<hr style="background: black;"/>
　　责任链模式是一种对象行为型模式，其主要优点如下：
~~~
降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。
~~~

　　<hr style="background: black;"/>
  　　其主要缺点如下:
~~~
不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。
~~~

## 27.3 结构

　　通常情况下，可以通过数据链表来实现职责链模式的数据结构。

　　<hr style="background: black;"/>
　　包含以下主要角色：
~~~
抽象处理者(Handler)角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
具体处理者(Concrete Handler)角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
客户类(Client)角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。
~~~

　　责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。









