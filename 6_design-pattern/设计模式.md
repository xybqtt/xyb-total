@[TOC](第4章 jvm)

# 0 格式
## 0.0 格式要求
　　换行前要求2个全角空格(html代码不要加全角空格)；
　　html代码后面一定加一行空行；
　　注意点、特点，如果换行，前面加2个全角空格；
　　标题后面需要添加空行；
　　列表全部使用ul标签控制；
　　https://www.cnblogs.com/cndarren/p/144152.html
　　视频地址：https://www.bilibili.com/video/BV1Kw411Z7dF?p=2&spm_id_from=pageDriver
　　每个大标题之间空2行，每个小标题之间空1行
　　<span style="color: red;"></span>
　　<hr style="height: 10px; background: green;"/>
　　<hr style="background: black;"/>
　　<div style="border: 5px black solid;"><div>
　　![avatar](pictures/11ThreadPool/11-1.png)
　　plantMUL(画UML类图)

# 1 设计模式7大原则
## 1.1 设计模式的目的

　　编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的
挑战，设计模式是为了让程序(软件)，具有更好
~~~
代码重用性 (即：相同功能的代码，不用多次编写)
可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
使程序呈现高内聚，低耦合的特性
分享金句：
设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”
Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤
~~~

## 1.2 设计模式的7大原则

　　设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)
<hr style="background: black;"/>
　　**设计模式常用的七大原则有:**
~~~
单一职责原
接口隔离原则
依赖倒转(倒置)原则
里氏替换原则
开闭原则
迪米特法则
合成复用原则
~~~
<hr style="background: black;"/>

## 1.3 单一职责原则
### 1.3.1 基本介绍

　　对类来说的，**即一个类应该只负责一项职责**。如类A负责两个不同职责：职责1，职责 2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1、A2。

### 1.3.2 单一职责原则注意事项和细节

~~~
降低类的复杂度，一个类只负责一项职责；
提高类的可读性，可维护性；
降低变更引起的风险；
通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。
~~~

## 1.4 接口隔离原则(Interface Segregation Principle)
### 1.4.1 基本介绍

　　客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。这里的依赖是指使用的意思，比如new A().f1(new B())，即说A依赖了B，本质就是使用。
　　具体查看代码。

## 1.5 依赖倒转原则
### 1.5.1 基本介绍

　　**依赖倒转原则(Dependence Inversion Principle)是指：**
~~~
高层模块不应该依赖低层模块，二者都应该依赖其抽象；
抽象不应该依赖细节，细节应该依赖抽象；
依赖倒转(倒置)的中心思想是面向接口编程；
依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类；
使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
~~~

### 1.5.2 依赖关系传递的三种方式和应用案例

　　就是说如何把实现类传给调用类。
~~~
接口传递，即new A().f1(new B()); f1的参数是个接口；
构造方法传递：new A(new B()).f1(); A的构造方法的参数是个接口，并将new B()作为成员变量；
setter方法传递：
    A a = new A(); 
    a.setB(new B());  // 将new B()设置为成员变量
    a.f1();
~~~

### 1.5.3 依赖倒转原则的注意事项和细节

~~~
低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好；就是说被别人使用的类，最好都有接口，如果有类似的类需要新增，直接用新类实现此接口就行，不用改变调用者的类。
变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化；就是说如果成员变量是接口或抽象类，那么以后如果接口有新的实现，此类的代码也不用变。
继承时遵循里氏替换原则。
~~~

## 1.6 里氏替换原则
### 1.6.1 OO中的继承性的思考和说明

~~~
继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏；
继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障；
问题提出：在编程中，如何正确的使用继承? => 里氏替换原则。
~~~

### 1.6.2基本介绍

~~~
里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的；
如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；
在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法；
里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。
~~~

### 1.6.3 解决方法

~~~
我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。
通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替.
~~~

## 1.7 开闭原则
### 1.7.1 基本介绍

~~~
开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则；
一个软件实体如类，模块和函数应该对扩展开放(对提供方，如A调用B，则A是提供方，B是修改方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节；
当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；
编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。
~~~

## 1.8 迪米特法则
### 1.8.1基本介绍

~~~
一个对象应该对其他对象保持最少的了解；
类与类关系越密切，耦合度越大；
迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息；
迪米特法则还有个更简单的定义：只与直接的朋友通信；
直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，如果类B出现在A的"成员变量、方法参数或方法返回值"中，则类B为类A的直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。
~~~

### 1.8.2 迪米特法则注意事项和细节

~~~
迪米特法则的核心是降低类之间的耦合；
但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。
~~~

## 1.9 合成复用原则（Composite Reuse Principle）
### 1.9.1 基本介绍

　　原则是尽量使用合成、聚合的方式，而不是使用继承。
　　<hr style="background: black;"/>
　　如果B类f2()方法想使用A类f1()，不要直接让B extends A，耦合度太高，而是建议以下3种方式：
~~~
依赖：f2(A a){}
聚合：set注入
class B {
    private A a;
    public void setA(A a) {}
}
组合：
class B {
    private A a = new A(); // 类似spring的自动注入方式
}
~~~

## 1.10 设计原则核心思想

~~~
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起；
针对接口编程，而不是针对实现编程；
为了交互对象之间的松耦合设计而努力。
~~~



# 2 UML类图
## 2.1 idea使用UML插件安装

~~~
File -> Settings -> Plugins -> PlantUML intergration安装插件；
https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi 安装graphviz软件到本地；
配置环境变量：
    配置GRAPHVIZ_HOME：本地安装目录(与JAVA_HOME类似)；
    配置GRAPHVIZ_DOT：变量值为%GRAPHVIZ_HOME%\bin\dot.exe
    配置Path：%GRAPHVIZ_HOME%\bin
    cmd -> dot -version 查看是否配置成功。
Settings -> 搜索plantuml -> graphviz dot executable 选择本地 安装目录\bin\dot.exe这个文件。
~~~

## 2.2 UML基本介绍

~~~
UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果；
UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等；
使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模。
~~~

## 2.3 UML图

　　画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类：
~~~
用例图(use case)；
静态结构图：类图(类图是描述类与类之间的关系的，是UML图中最核心的)、对象图、包图、组件图、部署图；
动态行为图：交互图（时序图与协作图）、状态图、活动图。
~~~

## 2.4 UML类图

~~~
用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系；
类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。
注意：类图中
    字段，是字段类型在":"之后，其它信息在之前，如"name : String"；
    方法返回值在":"之后，其它在之前，如"setName(name : String) : void"，参数也是一样，变量类型在后面。
~~~

### 2.4.1 依赖关系(Dependence)

　　只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。依赖表示要做一件事情，离不开某个对象。往往表现为B作为A的方法参数存在（A依赖B）
~~~
类中用到了对方；
如果是类的成员属性；
如果是方法的返回类型；
是方法接收的参数类型；
方法中使用到。
~~~

### 2.4.2 关联关系(Association)

　　关联关系实际上就是类与类之间的联系，是依赖关系的特例，即一个做为另一个的属性。关联表示has-a关系，如学生拥有一个课程，往往表现为B作为A的属性存在（A关联B）
~~~
关联关系具有导航性：即双向关联或单向关联；
关联关系具有多重性：如"1"表示有且仅有一个，"0"表示0个或多个，"0, 1"表示0或1个，"n...m"表示n到m个，"m...*"表示至少m个。
~~~

### 2.4.3 泛化关系(generalization)

　　泛化关系实际上就是继承关系，他是依赖关系的特例
~~~
泛化关系实际上就是继承关系；
如果 A extends B 类，我们就说A和B存在泛化关系。
~~~

### 2.4.4 实现关系(Implementation)

　　实现关系实际上就是 A 类实现 B 接口，是依赖关系的特例

### 2.4.5 聚合关系(Aggregation)

　　聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。
　　如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示。

### 2.4.6 组合关系(Composition)

　　组合关系：也是整体与部分的关系，但是整体与部分不可以分开，即成员变量 A a = new A()，和所属对象的生命周期一样，同生共死都算。
　　再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么Head和Person就是组合，IDCard和Person 就是聚合。
　　但是如果在程序中 Person 实体中定义了对IDCard进行级联删除，即删除 Person 时连同 IDCard 一起删除，那么IDCard和Person。

## 2.5 UML类图语法

　　语法介绍 https://plantuml.com/zh/class-diagram
　　**从上到下按如下格式来**
~~~
所有接口、类名称声明
所有类之间的关系描述
所有类属性、方法描述
~~~

### 2.5.1 元素声明

　　查看com\xyb\a2uml\1元素声明.puml。

### 2.5.2 类之间的关系与备注写法

~~~
<|、|>、^：空心三角形；
>、<：箭头；
*：代表实心菱形；
o：空心菱形；
--：实线；
..：虚线；
.或-越多线越长；一个.或-是垂直显示；
泛化的实现关系或以直接写extends和implements，uml依然会用实线、虚线显示，不过类前面要加class、interface
其余查看：com\xyb\a2uml\2类之间关系.puml
~~~

### 2.5.3 添加方法和属性

　　com\xyb\a2uml\3添加字段和方法.puml。
　　**特殊说明**
~~~
-、#、~、+：private、protected、package private、public，分别显示"正方形(red)、菱形(yellow)、三角形(blue)、圆形(green)"，修饰属性是空心，方法是实心；
类中的属性属性或方法，有()会被认为是方法(在属性下面的方框)，否则为属性(在类名下面的方框)；
{field}、{method}：被{field}修饰的会被认为是属性，即使有()，{method}修饰即使没()也被认为方法；
{static}、{classifier}、{abstract}：描述静态(显示下划线)、静态(显示下划线)、抽象(斜体)；
在类上面使用 'skinparam classAttributeIconSize 0'可以使'- # ~ +'失效
~~~

### 2.5.4 高级类体

　　PlantUML默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都是可用的：--、..、==、__。
　　还可以在分隔符中添加标题，查看com\xyb\a2uml\4高级类体.puml

### 2.5.6 备注和模板

　　com\xyb\a2uml\5备注和模板.puml
~~~
以下以左举例，上下右类似
方式1：在类声明的下一行
    class C1
    note left: 这是C1左侧的备注

方式2：在类声明的下面即可
    class C1
    note left on C1：这是C1左侧的备注

方式3：将note 起一个别名
    note "这是一个备注" as N1
    class C1
    class C2
    C1 .. N1 // 这里将N1这个备注添加到C1的下边或右边
    N1 .. C2 // 这里将N1这个备注添加到C2的上边或左边
~~~
<hr style="background: black;"/>

　　**备注可以使用html**
~~~
<b>
<u>
<i>
<s>, <del>, <strike>
<font color="#AAAAAA"> or <font color="colorName">
<color:#AAAAAA> or <color:colorName>
<size:nn> to change font size
<img src="file"> or <img:file>: the file must be accessible by the filesystem
~~~

### 2.5.7 注释属性和方法

　　com\xyb\a2uml\6注释属性和方法.puml

### 2.5.8 类成员的箭头方向(Arrows from/to class members)

　　可以关联A.field1和B.field2的关系，如LCCont.grpContNo = LcGrpCont.grpContNo



# 3 设计模式概述
## 3.1 设计模式介绍

~~~
设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的；
设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度；
<<设计模式>> 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）；
设计模式并不局限于某种语言，java，php，c++ 都有设计模式。
~~~

## 3.2 设计模式类型

　　**设计模式分为三种类型，共 23 种**
~~~
创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式；
结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；
行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)
~~~



# 5 单例设计模式
## 5.1 单例设计模式介绍

　　所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。

## 5.2 单例设计模式的几种种方式

~~~
饿汉式(线程安全，"静态常量"或"静态代码块")；
懒汉式(线程安全，同步方法)；
双重检查(推荐使用)；
静态内部类；
枚举。
~~~

<hr style="background: black;"/>

　　**饿汉式(静态常量)、(静态代码块)**
~~~
步骤
    构造器私有化 (防止 new)；
    类的内部创建对象，在类初始化阶段<clinit>()；
    向外暴露一个静态的公共方法，getInstance。
    查看：com\xyb\a3singleton\A1Singleton.java

优缺点说明：
优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题；
缺点：
    在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费；
这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果；
结论：这种单例模式可用，可能造成内存浪费
~~~

<hr style="background: black;"/>

　　**懒汉式(线程安全，不推荐使用)**
~~~
步骤：
    提供一个静态的公有方法，当使用到该方法时，才去创建 instance；
    查看：com\xyb\a3singleton\A2LazyLoading.java。

优缺点说明：
    效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低。

结论：在实际开发中，不推荐使用这种方式。
~~~

<hr style="background: black;"/>

　　**双重检查(推荐使用)**
~~~
优缺点说明：
    Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。
    这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步. 
    线程安全；延迟加载；效率较高。
查看：com\xyb\a3singleton\A3DoubleCheck.java

注意，单例前必须加上volatile关键字。TODO

结论：在实际开发中，推荐使用这种单例设计模式
~~~

<hr style="background: black;"/>

　　**静态内部类(推荐使用)**
~~~
其实是"饿汉式"的变化，"饿汉式"的缺点是每个类只要初始化<clinit>()，则单例对象必定被创建，占用内存，那如果将这个单例对象写在私有静态内部类里面，只有在获取单例对象的时候，内部类才进行初始化<clinit>()，那不也相当于lazy loading，而且加载过程<clinit>()也是线程安全的，推荐使用。

优缺点说明：
    这种方式采用了类装载的机制来保证初始化实例时只有一个线程；
    静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。
    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
    优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
查看：com\xyb\a3singleton\A4StaticInnerClass.java。

结论：推荐使用
~~~

<hr style="background: black;"/>

　　**枚举(推荐使用)**
~~~
优缺点说明：
    这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建
新的对象。
    这种方式是 Effective Java 作者 Josh提倡的方式。
~~~

## 5.3 单例模式在 JDK 应用的源码
### 5.3.1 单例模式在 JDK 应用的源码分析

　　Runtime这个类就是使用的"饿汉式"单例模式。

### 5.3.2 单例模式注意事项和细节说明

~~~
单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new；
单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)。
~~~



# 6 工厂模式
## 6.1 简单工厂模式
### 6.1.1 基本介绍

~~~
简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式；
简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)；
在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。
查看：com\xyb\a4factory\a2simple。
~~~

## 6.2 工厂方法模式

　　工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
　　查看com\xyb\a4factory\a3factorymethod。

## 6.3 抽象工厂模式

~~~
抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类；
抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合；
从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)；
将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

查看com\xyb\a4factory\a4absfactory。
~~~

## 6.4 工厂模式在 JDK-Calendar 应用的源码分析

　　JDK 中的 Calendar 类中，就使用了简单工厂模式



# 7 原型模式
## 7.1 定义与特点

~~~
原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。它属于创建型设计模式，用于创建重复的对象，同时又能保证性能（用这种方式创建对象非常高效）。
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
~~~

## 7.2 优缺点

~~~
性能优良：原型模式是在内存二进制流的拷贝，要比new一个对象性能好很多，特别是在一个循环体类产生大量对象的时候更加明显；
逃避构造函数的约束：这是优缺点共存的一点，直接在内存中拷贝，构造函数是不会执行的。
需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。
~~~

## 7.3 使用场景

~~~
资源初始化场景：类初始化需要消耗非常多的资源的时候；
性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备和访问权限的时候；
一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而各个调用者可能都需要修改其值时考虑使用；
实际项目中原型模式很少单独出现，一般和工厂模式一起出现，通过clone方法创建一个对象，然后由工厂方法提供给调用者。
~~~

## 7.4 结构与实现

　　由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单，只需要实现Cloneable接口并重写clone()方法，简单程度仅次于单例模式和迭代器模式。
　　原型模式包含以下主要角色：
~~~
抽象原型类：规定了具体原型对象必须实现的接口，java中即Cloneable接口；
具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象，即被克隆对象的类；
访问类：使用具体原型类中的 clone() 方法来复制新的对象，即使用克隆后对象的类。
查看com\xyb\a5prototype\A1PrototypeCls.java。
~~~

　　注意：构造方法在clone的时候并不会执行，因为对象是从内存以二进制流的方式进行拷贝，当然不会执行。

## 7.5 深拷贝、浅拷贝

　　查看com\xyb\a5prototype\2深浅拷贝.puml，对对象A进行浅拷贝是指复制A中所有属性的值(基本类型记录值、引用类型记录存的地址)。

　　深拷贝
~~~
复制对象的所有基本数据类型的成员变量值；
为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
深拷贝实现方式 1：重写 clone 方法来实现深拷贝(不推荐，需要让此对象可达的对象的类实现Cloneable接口)；
深拷贝实现方式 2：通过对象序列化实现深拷贝(推荐）
~~~



# 8 建造者模式
## 8.1 基本介绍

~~~
建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象；
建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
简单来说，有2种建造者模式：
    1、直接返回一个有默认值的对象，比如JVM参数，当你运行一个main方法时，即使什么也不设置，也可以运行，因为它默认把这些参数都设置了，你可以直接使用；
    2、通过set方法返回此Builder，使其可以继续设置属性，最终返回一个对象。
~~~

## 8.2 建造者模式的4个对象

~~~
Product(产品角色)：一个具体的产品对象；
Builder(抽象建造者)：创建一个Product对象的各个部件指定的 接口/抽象类；
ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件；
Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。
查看：com\xyb\a6builder\1建造者模式.puml。
~~~

## 8.3 建造者模式在 JDK 的应用和源码分析

　　java.lang.StringBuilder 中的建造者模式
~~~
Appendable接口定义了多个append方法(抽象方法)，即Appendable为抽象建造者，定义了抽象方法；
AbstractStringBuilder实现了Appendable接口方法，这里的AbstractStringBuilder已经是建造者，只是不能实例化；
StringBuilder即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了 AbstractStringBuilder。
~~~

## 8.4 建造者模式的注意事项和细节

~~~
客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象；
每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象；
可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程；
增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合"开闭原则"；
建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制；
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。
~~~

## 8.5 抽象工厂模式 VS 建造者模式

　　抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。



# 9 适配器设计模式
## 9.1 基本介绍

~~~
适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)；
适配器模式属于结构型模式；
主要分为三类：类适配器模式、对象适配器模式、接口适配器模式(缺省适配器模式)。
~~~

## 9.2 工作原理

~~~
适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容；
从用户的角度看不到被适配者，是解耦的；
用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法；
用户收到反馈结果，感觉只是和目标接口交互。
~~~

## 9.3 类适配器模式

　　基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。
　　即A类想用b()方法，但是没有b()，就让A类的子类B添加这个b()，那么直接调用B.b()就实现A类调用了b()方法(B类也是A类)，那怎么让B有b()方法，让B实现接口中有b()的接口。

~~~
源(Adaptee)：需要被适配的对象或类型，相当于插头；
适配器(Adapter)：连接目标和源的中间对象，相当于插头转换器；
目标(Target)：期待得到的目标，相当于插座。
~~~

### 9.3.1 类适配器模式注意事项和细节

~~~
Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性；
src类的方法在Adapter中都会暴露出来，也增加了使用的成本；
由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。
~~~

## 9.4 对象适配器模式
### 9.4.1 模式介绍

~~~
基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配；
根据"合成复用原则"，在系统中尽量使用关联关系（聚合）来替代继承关系；
对象适配器模式是适配器模式常用的一种。
~~~

### 9.4.2 对象适配器模式注意事项和细节

~~~
对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。
根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口；
使用成本更低，更灵活。
~~~

## 9.5 接口适配器模式
### 9.5.1 接口适配器模式介绍

~~~
一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式；
核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求；
适用于一个接口不想使用其所有的方法的情况。
JDK8以后接口可以用default修饰方法，同样可以实现。
~~~

## 9.6 适配器模式在 SpringMVC 框架应用的源码剖析

~~~
SpringMvc中的HandlerAdapter，就使用了适配器模式
SpringMVC 处理请求的流程回顾
    使用HandlerAdapter的原因分析:
    可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则。
~~~

## 9.7 适配器模式的注意事项和细节

~~~
三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的：
    类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承；
    对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有；
    接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现。
Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作；
实际开发中，实现起来不拘泥于我们讲解的三种经典形式。
~~~



# 10 桥接模式
## 10.1 基本介绍

　　桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

## 10.2 优缺点

~~~
优点：
    抽象与实现分离，扩展能力强；
    符合开闭原则；
    符合合成复用原则；
    其实现细节对客户透明。
缺点：
    由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。
~~~

## 10.3 主要角色

~~~
抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用；
扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法；
实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用；
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。
具体查看com\xyb\a8bridge\1桥接模式.puml。
~~~

## 10.4 桥接模式在 JDBC 的源码剖析


## 10.5 桥接模式的注意事项和细节

~~~
实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统；
对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成；
桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本；
桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程；
桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。

桥接模式其它应用场景：对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适合。
~~~

## 10.6 常见的应用场景

~~~
JDBC 驱动程序
银行转账系统
    转账分类: 网上转账，柜台转账，AMT 转账
    转账用户类型：普通用户，银卡用户，金卡用户.. 
3) -消息管理
    消息类型：即时消息，延时消息
    消息分类：手机短信，邮件消息，QQ 消息
~~~



# 11 装饰者模式
